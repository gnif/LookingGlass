/**
 * Looking Glass
 * Copyright Â© 2017-2024 The Looking Glass Authors
 * https://looking-glass.io
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 2 of the License, or (at your option)
 * any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc., 59
 * Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */

#include "desktop.h"
#include "common/debug.h"

#include <stdlib.h>
#include <string.h>

#include "vulkan_util.h"

// these headers are auto generated by cmake
#include "desktop.frag.spv.h"

struct Vulkan_Desktop
{
  struct VkPhysicalDeviceMemoryProperties * memoryProperties;
  VkDevice          device;
  VkQueue           queue;
  VkShaderModule    vertexShader;
  VkShaderModule    fragmentShader;
  VkCommandBuffer   commandBuffer;
  VkDescriptorPool  descriptorPool;
  VkDescriptorSet   descriptorSet;
  VkPipelineLayout  pipelineLayout;
  VkFence           fence;

  VkBuffer          uniformBuffer;
  VkDeviceMemory    uniformBufferMemory;
  void            * uniformBufferMap;

  VkPipeline        pipeline;

  VkImage           image;
  VkImageView       imageView;
  VkDeviceSize      imagePitch;
  VkDeviceMemory    imageMemory;
  void            * imageMap;
  VkFormat          imageFormat;
  VkExtent2D        imageExtent;

  unsigned int      formatPitch;
  unsigned int      formatBpp;
};

bool vulkan_desktopInit(Vulkan_Desktop ** desktop_,
    struct VkPhysicalDeviceMemoryProperties * memoryProperties, VkDevice device,
    VkQueue queue, VkShaderModule vertexShader, VkCommandBuffer commandBuffer,
    VkDescriptorSetLayout descriptorSetLayout, VkDescriptorPool descriptorPool,
    VkPipelineLayout pipelineLayout, VkFence fence)
{
  Vulkan_Desktop * desktop = calloc(1, sizeof(Vulkan_Desktop));
  if (!desktop)
  {
    DEBUG_ERROR("Failed to malloc Vulkan_Desktop");
    goto err;
  }
  *desktop_ = desktop;

  desktop->memoryProperties = memoryProperties;
  desktop->device = device;
  desktop->queue = queue;
  desktop->vertexShader = vertexShader;
  desktop->commandBuffer = commandBuffer;
  desktop->descriptorPool = descriptorPool;
  desktop->pipelineLayout = pipelineLayout;
  desktop->fence = fence;

  desktop->fragmentShader = vulkan_loadShader(device,
      b_shader_desktop_frag_spv, b_shader_desktop_frag_spv_size - 1);
  if (!desktop->fragmentShader)
    goto err_desktop;

  desktop->descriptorSet = vulkan_allocateDescriptorSet(device,
      descriptorSetLayout, descriptorPool);
  if (!desktop->descriptorSet)
    goto err_shader;

  desktop->uniformBuffer = vulkan_createBuffer(memoryProperties,
      device, sizeof(struct VulkanUniformBuffer),
      VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT, &desktop->uniformBufferMemory,
      &desktop->uniformBufferMap);
  if (!desktop->uniformBuffer)
    goto err_descriptor_set;

  return true;

err_descriptor_set:
  vkFreeDescriptorSets(device, descriptorPool, 1, &desktop->descriptorSet);

err_shader:
  vkDestroyShaderModule(device, desktop->fragmentShader, NULL);

err_desktop:
  free(desktop);

err:
  return false;
}

static void freeImage(Vulkan_Desktop * this)
{
  if (this->imageView)
  {
    vkDestroyImageView(this->device, this->imageView, NULL);
    this->imageView = NULL;
  }

  if (this->image)
  {
    vkDestroyImage(this->device, this->image, NULL);
    this->image = NULL;
    this->imageFormat = VK_FORMAT_UNDEFINED;
    this->imageExtent.width = 0;
    this->imageExtent.height = 0;
  }

  if (this->imageMap)
  {
    vkUnmapMemory(this->device, this->imageMemory);
    this->imageMap = NULL;
  }

  if (this->imageMemory)
  {
    vkFreeMemory(this->device, this->imageMemory, NULL);
    this->imageMemory = NULL;
  }
}

void vulkan_desktopFree(Vulkan_Desktop ** desktop)
{
  if (!*desktop)
    return;

  freeImage(*desktop);

  if ((*desktop)->pipeline)
    vkDestroyPipeline((*desktop)->device, (*desktop)->pipeline, NULL);

  vulkan_freeBuffer((*desktop)->device, &(*desktop)->uniformBuffer,
      &(*desktop)->uniformBufferMemory, &(*desktop)->uniformBufferMap);

  vkFreeDescriptorSets((*desktop)->device, (*desktop)->descriptorPool, 1,
      &(*desktop)->descriptorSet);

  vkDestroyShaderModule((*desktop)->device, (*desktop)->fragmentShader, NULL);

  free(*desktop);
  *desktop = NULL;
}

bool vulkan_desktopInitPipeline(Vulkan_Desktop * this, VkRenderPass renderPass)
{
  if (this->pipeline)
  {
    vkDestroyPipeline(this->device, this->pipeline, NULL);
    this->pipeline = NULL;
  }

  this->pipeline = vulkan_createGraphicsPipeline(this->device,
      this->vertexShader, this->fragmentShader, NULL, this->pipelineLayout,
      renderPass);
  if (!this->pipeline)
    return false;

  return true;
}

static VkFormat selectImageFormat(const LG_RendererFormat * format)
{
  switch (format->type)
  {
    case FRAME_TYPE_BGRA:
      return VK_FORMAT_B8G8R8A8_UNORM;
    case FRAME_TYPE_RGBA:
      return VK_FORMAT_R8G8B8A8_UNORM;
    case FRAME_TYPE_RGBA10:
      return VK_FORMAT_A2B10G10R10_UNORM_PACK32;
    case FRAME_TYPE_RGBA16F:
      return VK_FORMAT_R16G16B16A16_SFLOAT;
    case FRAME_TYPE_BGR_32:
      DEBUG_FATAL("FRAME_TYPE_BGR_32 not implemented");
    case FRAME_TYPE_RGB_24:
      DEBUG_FATAL("FRAME_TYPE_RGB_24 not implemented");
    default:
      DEBUG_FATAL("Could not determine Vulkan format for frame type %d",
          format->type);
  }
}

static bool initImage(Vulkan_Desktop * this)
{
  if (!vulkan_beginCommandBuffer(this->commandBuffer))
    goto err;

  struct VkImageMemoryBarrier preImageBarrier =
  {
    .sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,
    .srcAccessMask = VK_ACCESS_NONE,
    .dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT,
    .oldLayout = VK_IMAGE_LAYOUT_UNDEFINED,
    .newLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
    .srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
    .dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
    .image = this->image,
    .subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT,
    .subresourceRange.levelCount = 1,
    .subresourceRange.layerCount = 1
  };

  vkCmdPipelineBarrier(this->commandBuffer, VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,
      VK_PIPELINE_STAGE_TRANSFER_BIT, 0, 0, NULL, 0, NULL, 1,
      &preImageBarrier);

  union VkClearColorValue clearValue =
  {
    .float32 = { 0.0f, 0.0f, 0.0f, 0.0f }
  };

  struct VkImageSubresourceRange range =
  {
    .aspectMask = VK_IMAGE_ASPECT_COLOR_BIT,
    .levelCount = 1,
    .layerCount = 1
  };

  vkCmdClearColorImage(this->commandBuffer, this->image,
      VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, &clearValue, 1, &range);

  struct VkImageMemoryBarrier postImageBarrier =
  {
    .sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,
    .srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT,
    .dstAccessMask = VK_ACCESS_NONE,
    .oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
    .newLayout = VK_IMAGE_LAYOUT_GENERAL,
    .srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
    .dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
    .image = this->image,
    .subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT,
    .subresourceRange.levelCount = 1,
    .subresourceRange.layerCount = 1
  };

  vkCmdPipelineBarrier(this->commandBuffer, VK_PIPELINE_STAGE_TRANSFER_BIT,
      VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT, 0, 0, NULL, 0, NULL, 1,
      &postImageBarrier);

  if (!vulkan_endCommandBuffer(this->commandBuffer))
    goto err;

  struct VkSubmitInfo submitInfo =
  {
    .sType = VK_STRUCTURE_TYPE_SUBMIT_INFO,
    .commandBufferCount = 1,
    .pCommandBuffers = &this->commandBuffer
  };

  VkResult result = vkQueueSubmit(this->queue, 1, &submitInfo, this->fence);
  if (result != VK_SUCCESS)
  {
    DEBUG_ERROR("Failed to submit command buffer (VkResult: %d)", result);
    goto err;
  }

  if (!vulkan_waitFence(this->device, this->fence))
    goto err_wait;

  return true;

err_wait:
  vkQueueWaitIdle(this->queue);

err:
  return false;
}

static bool createImage(Vulkan_Desktop * this, const LG_RendererFormat * format,
    VkFormat imageFormat)
{
  freeImage(this);

  struct VkImageCreateInfo createInfo =
  {
    .sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
    .imageType = VK_IMAGE_TYPE_2D,
    .format = imageFormat,
    .extent.width = format->frameWidth,
    .extent.height = format->frameHeight,
    .extent.depth = 1,
    .mipLevels = 1,
    .arrayLayers = 1,
    .samples = VK_SAMPLE_COUNT_1_BIT,
    .tiling = VK_IMAGE_TILING_LINEAR,
    .usage = VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT,
    .sharingMode = VK_SHARING_MODE_EXCLUSIVE,
    .initialLayout = VK_IMAGE_LAYOUT_UNDEFINED
  };

  VkResult result = vkCreateImage(this->device, &createInfo, NULL,
      &this->image);
  if (result != VK_SUCCESS)
  {
    DEBUG_ERROR("Failed to create desktop image (VkResult: %d)", result);
    goto err;
  }

  struct VkMemoryRequirements memoryRequirements;
  vkGetImageMemoryRequirements(this->device, this->image, &memoryRequirements);

  this->imageMemory = vulkan_allocateMemory(this->memoryProperties,
      this->device, &memoryRequirements,
      VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT |
      VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |
      VK_MEMORY_PROPERTY_HOST_COHERENT_BIT);
  if (!this->imageMemory)
    goto err_image;

  result = vkBindImageMemory(this->device, this->image, this->imageMemory, 0);
  if (result != VK_SUCCESS)
  {
    DEBUG_ERROR("Failed to bind desktop image memory (VkResult: %d)", result);
    goto err_memory;
  }

  if (!initImage(this))
    goto err_memory;

  result = vkMapMemory(this->device, this->imageMemory, 0, VK_WHOLE_SIZE,
      0, &this->imageMap);
  if (result != VK_SUCCESS)
  {
    DEBUG_ERROR("Failed to map desktop image memory (VkResult: %d)", result);
    goto err_memory;
  }

  this->imageView = vulkan_createImageView(this->device, this->image,
      createInfo.format);
  if (!this->imageView)
    goto err_memory_map;

  VkImageSubresource subresource =
  {
    .aspectMask = VK_IMAGE_ASPECT_COLOR_BIT
  };
  VkSubresourceLayout subresourceLayout;
  vkGetImageSubresourceLayout(this->device, this->image, &subresource,
      &subresourceLayout);

  this->imagePitch = subresourceLayout.rowPitch;
  this->imageFormat = createInfo.format;
  this->imageExtent.width = createInfo.extent.width;
  this->imageExtent.height = createInfo.extent.height;
  return true;

err_memory_map:
  vkUnmapMemory(this->device, this->imageMemory);
  this->imageMap = NULL;

err_memory:
  vkFreeMemory(this->device, this->imageMemory, NULL);
  this->imageMemory = NULL;

err_image:
  vkDestroyImage(this->device, this->image, NULL);
  this->image = NULL;

err:
  return false;
}

bool vulkan_desktopInitFormat(Vulkan_Desktop * this,
    const LG_RendererFormat * format)
{
  if (format->type == FRAME_TYPE_INVALID)
  {
    freeImage(this);
    return true;
  }

  VkFormat imageFormat = selectImageFormat(format);

  bool formatChanged = imageFormat != this->imageFormat;
  bool sizeChanged =
      format->frameWidth != this->imageExtent.width ||
      format->frameHeight != this->imageExtent.height;

  if (formatChanged || sizeChanged)
  {
    if (!createImage(this, format, imageFormat))
      return false;

    vulkan_updateDescriptorSet1(this->device, this->descriptorSet,
        this->uniformBuffer, this->imageView, VK_IMAGE_LAYOUT_GENERAL);
  }

  this->formatPitch = format->pitch;
  this->formatBpp = format->bpp;

  return true;
}

bool vulkan_desktopUpdate(Vulkan_Desktop * this, const FrameBuffer * frame)
{
  if (!framebuffer_read(frame, this->imageMap, this->imagePitch,
      this->imageExtent.height, this->imageExtent.width, this->formatBpp,
      this->formatPitch))
  {
    DEBUG_ERROR("Failed to read from frame buffer");
    return false;
  }

  return true;
}

bool vulkan_desktopRender(Vulkan_Desktop * this, float translateX,
    float translateY, float scaleX, float scaleY, LG_RendererRotate rotate,
    float whiteLevel)
{
  if (!this->image)
    return false;

  vulkan_updateUniformBuffer(this->uniformBufferMap, translateX, translateY,
      scaleX, scaleY, rotate, whiteLevel);

  vkCmdBindPipeline(this->commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS,
      this->pipeline);

  vkCmdBindDescriptorSets(this->commandBuffer,
      VK_PIPELINE_BIND_POINT_GRAPHICS, this->pipelineLayout, 1, 1,
      &this->descriptorSet, 0, NULL);

  vkCmdDraw(this->commandBuffer, 3, 1, 0, 0);

  return true;
}
