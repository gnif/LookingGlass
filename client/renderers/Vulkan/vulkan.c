/**
 * Looking Glass
 * Copyright Â© 2017-2024 The Looking Glass Authors
 * https://looking-glass.io
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 2 of the License, or (at your option)
 * any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc., 59
 * Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */

#include "interface/renderer.h"

#include "common/array.h"

#include <vulkan/vulkan.h>

#include <string.h>

#include "cursor.h"
#include "extensions.h"
#include "imgui.h"
#include "vulkan_util.h"

// these headers are auto generated by cmake
#include "basic.frag.spv.h"
#include "fullscreen.vert.spv.h"
#include "transform_texture.vert.spv.h"

struct Inst
{
  LG_Renderer base;

  VkInstance            instance;
  VkSurfaceKHR          surface;
  VkPhysicalDevice      physicalDevice;
  uint32_t              queueFamilyIndex;
  struct VkPhysicalDeviceMemoryProperties memoryProperties;
  VkDevice              device;
  VkQueue               queue;
  VkShaderModule        fullScreenVertexShader;
  VkShaderModule        transformTextureVertexShader;
  VkShaderModule        fragmentShader;
  VkCommandPool         commandPool;
  VkCommandBuffer       commandBuffer;
  VkSampler             sampler;
  VkDescriptorSetLayout descriptorSetLayouts[2];
  VkDescriptorPool      descriptorPool;
  VkDescriptorSet       descriptorSets[2];
  VkPipelineLayout      pipelineLayout;
  VkSemaphore           swapchainAcquireSemaphore;
  VkSemaphore           swapchainReleaseSemaphore;
  VkFence               fence;

  VkSwapchainKHR   swapchain;
  VkFormat         swapchainFormat;
  VkExtent2D       swapchainExtent;
  uint32_t         swapchainImageCount;
  VkImage        * swapchainImages;
  VkImageView    * swapchainImageViews;
  VkRenderPass     renderPass;
  VkPipeline       pipeline;
  VkFramebuffer  * framebuffers;

  VkImage          desktopImage;
  VkImageView      desktopImageView;
  VkDeviceSize     desktopImagePitch;
  VkDeviceMemory   desktopImageMemory;
  void           * desktopImageMap;
  VkImageLayout    desktopImageLayout;
  VkFormat         desktopFormat;
  VkExtent2D       desktopExtent;

  VkBuffer         desktopUniformBuffer;
  VkDeviceMemory   desktopUniformBufferMemory;
  void           * desktopUniformBufferMap;

  Vulkan_Cursor  * cursor;

  Vulkan_ImGui   * imGui;
  VkImage          imGuiImage;
  VkImageView      imGuiImageView;
  VkDeviceMemory   imGuiImageMemory;

  LG_RendererFormat format;
  bool              formatValid;

  int               width, height;
  struct DoubleRect destRect;
  LG_RendererRotate rotate; //client side rotation

  float translateX  , translateY;
  float scaleX      , scaleY;

  bool  cursorVisible;
  int   cursorX    , cursorY;
  int   cursorHX   , cursorHY;
  float mouseWidth , mouseHeight;
  float mouseScaleX, mouseScaleY;

  PFN_vkSetHdrMetadataEXT vkSetHdrMetadataEXT;
};

static const char * vulkan_getName(void)
{
  return "Vulkan";
}

static void vulkan_setup(void)
{
}

static bool vulkan_create(LG_Renderer ** renderer, const LG_RendererParams params,
    bool * needsOpenGL)
{
  struct Inst * this = calloc(1, sizeof(*this));
  if (!this)
  {
    DEBUG_INFO("Failed to allocate %lu bytes", sizeof(*this));
    return false;
  }
  *renderer = &this->base;

  *needsOpenGL = false;
  return true;
}

static bool vulkan_initialize(LG_Renderer * renderer)
{
  return true;
}

static void vulkan_freeImGuiImage(struct Inst * this)
{
  if (this->imGuiImageView)
  {
    vkDestroyImageView(this->device, this->imGuiImageView, NULL);
    this->imGuiImageView = NULL;
  }

  if (this->imGuiImage)
  {
    vkDestroyImage(this->device, this->imGuiImage, NULL);
    this->imGuiImage = NULL;
  }

  if (this->imGuiImageMemory)
  {
    vkFreeMemory(this->device, this->imGuiImageMemory, NULL);
    this->imGuiImageMemory = NULL;
  }
}

static void vulkan_freeDesktopImage(struct Inst * this)
{
  if (this->desktopImageView)
  {
    vkDestroyImageView(this->device, this->desktopImageView, NULL);
    this->desktopImageView = NULL;
  }

  if (this->desktopImage)
  {
    vkDestroyImage(this->device, this->desktopImage, NULL);
    this->desktopImage = NULL;
    this->desktopImageLayout = VK_IMAGE_LAYOUT_UNDEFINED;
    this->desktopFormat = VK_FORMAT_UNDEFINED;
    this->desktopExtent.width = 0;
    this->desktopExtent.height = 0;
  }

  if (this->desktopImageMap)
  {
    vkUnmapMemory(this->device, this->desktopImageMemory);
    this->desktopImageMap = NULL;
  }

  if (this->desktopImageMemory)
  {
    vkFreeMemory(this->device, this->desktopImageMemory, NULL);
    this->desktopImageMemory = NULL;
  }
}

static void vulkan_freeDesktopUniformBuffer(struct Inst * this)
{
  if (this->desktopUniformBuffer)
  {
    vkDestroyBuffer(this->device, this->desktopUniformBuffer, NULL);
    this->desktopUniformBuffer = NULL;
  }

  if (this->desktopUniformBufferMap)
  {
    vkUnmapMemory(this->device, this->desktopUniformBufferMemory);
    this->desktopUniformBufferMap = NULL;
  }

  if (this->desktopUniformBufferMemory)
  {
    vkFreeMemory(this->device, this->desktopUniformBufferMemory, NULL);
    this->desktopUniformBufferMemory = NULL;
  }
}

static void vulkan_freeSwapchain(struct Inst * this)
{
  if (this->swapchainImageViews)
  {
    for (uint32_t i = 0; i < this->swapchainImageCount; ++i)
    {
      if (this->swapchainImageViews[i])
        vkDestroyImageView(this->device, this->swapchainImageViews[i], NULL);
    }
    free(this->swapchainImageViews);
    this->swapchainImageViews = NULL;
  }

  if (this->swapchainImages)
  {
    free(this->swapchainImages);
    this->swapchainImages = NULL;
    this->swapchainImageCount = 0;
  }

  if (this->swapchain)
  {
    vkDestroySwapchainKHR(this->device, this->swapchain, NULL);
    this->swapchain = NULL;
    this->swapchainFormat = VK_FORMAT_UNDEFINED;
    this->swapchainExtent.width = 0;
    this->swapchainExtent.height = 0;
  }
}

static void vulkan_freeFramebuffers(struct Inst * this)
{
  if (this->framebuffers)
  {
    for (uint32_t i = 0; i < this->swapchainImageCount; ++i)
    {
      if (this->framebuffers[i])
        vkDestroyFramebuffer(this->device, this->framebuffers[i], NULL);
    }
    free(this->framebuffers);
    this->framebuffers = NULL;
  }
}

static void vulkan_deinitialize(LG_Renderer * renderer)
{
  struct Inst * this = UPCAST(struct Inst, renderer);

  if (this->device)
    vkDeviceWaitIdle(this->device);

  vulkan_freeImGuiImage(this);

  if (this->imGui)
    vulkan_imGuiFree(&this->imGui);

  if (this->cursor)
    vulkan_cursorFree(&this->cursor);

  vulkan_freeDesktopUniformBuffer(this);

  vulkan_freeDesktopImage(this);

  vulkan_freeFramebuffers(this);
  
  if (this->pipeline)
    vkDestroyPipeline(this->device, this->pipeline, NULL);

  if (this->renderPass)
    vkDestroyRenderPass(this->device, this->renderPass, NULL);

  vulkan_freeSwapchain(this);

  if (this->fence)
    vkDestroyFence(this->device, this->fence, NULL);

  if (this->swapchainReleaseSemaphore)
    vkDestroySemaphore(this->device, this->swapchainReleaseSemaphore, NULL);

  if (this->swapchainAcquireSemaphore)
    vkDestroySemaphore(this->device, this->swapchainAcquireSemaphore, NULL);

  if (this->pipelineLayout)
    vkDestroyPipelineLayout(this->device, this->pipelineLayout, NULL);

  if (this->descriptorPool)
    vkDestroyDescriptorPool(this->device, this->descriptorPool, NULL);

  for (int i = 0; i < ARRAY_LENGTH(this->descriptorSetLayouts); ++i)
    if (this->descriptorSetLayouts[i])
      vkDestroyDescriptorSetLayout(this->device, this->descriptorSetLayouts[i],
          NULL);

  if (this->sampler)
    vkDestroySampler(this->device, this->sampler, NULL);

  if (this->commandPool)
    vkDestroyCommandPool(this->device, this->commandPool, NULL);

  if (this->fragmentShader)
    vkDestroyShaderModule(this->device, this->fragmentShader, NULL);

  if (this->transformTextureVertexShader)
    vkDestroyShaderModule(this->device, this->transformTextureVertexShader,
        NULL);

  if (this->fullScreenVertexShader)
    vkDestroyShaderModule(this->device, this->fullScreenVertexShader, NULL);

  if (this->device)
    vkDestroyDevice(this->device, NULL);

  if (this->surface)
    vkDestroySurfaceKHR(this->instance, this->surface, NULL);

  if (this->instance)
    vkDestroyInstance(this->instance, NULL);

  free(this);
}

static bool vulkan_supports(LG_Renderer * renderer, LG_RendererSupport flag)
{
  return false;
}

static void vulkan_onRestart(LG_Renderer * renderer)
{
}

static bool vulkan_getSwapchainImages(struct Inst * this)
{
  uint32_t imageCount;
  VkResult result = vkGetSwapchainImagesKHR(this->device, this->swapchain,
      &imageCount, NULL);
  if (result != VK_SUCCESS)
  {
    DEBUG_ERROR("Failed to get swapchain images (VkResult: %d)", result);
    goto err;
  }

  VkImage * images = malloc(sizeof(VkImage) * imageCount);
  if (!images)
  {
    DEBUG_ERROR("out of memory");
    goto err;
  }

  result = vkGetSwapchainImagesKHR(this->device, this->swapchain, &imageCount,
      images);
  if (result != VK_SUCCESS)
  {
    DEBUG_ERROR("Failed to get swapchain images (VkResult: %d)", result);
    goto err_images;
  }

  VkImageView * imageViews = calloc(imageCount, sizeof(VkImageView));
  if (!imageViews)
  {
    DEBUG_ERROR("out of memory");
    goto err_images;
  }

  for (uint32_t i = 0; i < imageCount; ++i)
  {
    imageViews[i] = vulkan_createImageView(this->device, images[i],
        this->swapchainFormat);
    if (!imageViews[i]) {
      goto err_image_views;
    }
  }

  this->swapchainImageCount = imageCount;
  this->swapchainImages = images;
  this->swapchainImageViews = imageViews;
  return true;

err_image_views:
  for (uint32_t i = 0; i < imageCount; ++i)
  {
    if (imageViews[i])
      vkDestroyImageView(this->device, imageViews[i], NULL);
  }
  free(imageViews);

err_images:
  free(images);

err:
  return false;
}

static VkSurfaceFormatKHR vulkan_selectSurfaceFormat(struct Inst * this)
{
  struct VkSurfaceFormatKHR format =
  {
    .format = VK_FORMAT_UNDEFINED
  };

  uint32_t formatCount;
  VkResult result = vkGetPhysicalDeviceSurfaceFormatsKHR(this->physicalDevice,
      this->surface, &formatCount, NULL);
  if (result != VK_SUCCESS)
  {
    DEBUG_ERROR("Failed to get surface formats (VkResult: %d)", result);
    goto err;
  }

  VkSurfaceFormatKHR * formats = malloc(
      sizeof(VkSurfaceFormatKHR) * formatCount);
  if (!formats)
  {
    DEBUG_ERROR("out of memory");
    goto err;
  }

  result = vkGetPhysicalDeviceSurfaceFormatsKHR(this->physicalDevice,
      this->surface, &formatCount, formats);
  if (result != VK_SUCCESS)
  {
    DEBUG_ERROR("Failed to get surface formats (VkResult: %d)", result);
    goto err_formats;
  }

  VkFormat hdrFormat = VK_FORMAT_UNDEFINED;
  VkColorSpaceKHR hdrColorSpace = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR;
  if (this->format.type == FRAME_TYPE_RGBA16F)
  {
    hdrFormat = VK_FORMAT_R16G16B16A16_SFLOAT;
    hdrColorSpace = VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT;
  }
  else if (this->format.type == FRAME_TYPE_RGBA10)
  {
    hdrFormat = VK_FORMAT_A2B10G10R10_UNORM_PACK32;
    hdrColorSpace = this->format.hdrPQ ?
        VK_COLOR_SPACE_HDR10_ST2084_EXT :
        VK_COLOR_SPACE_SRGB_NONLINEAR_KHR;
  }

  uint32_t formatIndex = UINT32_MAX;
  if (hdrFormat != VK_FORMAT_UNDEFINED)
  {
    for (uint32_t i = 0; i < formatCount; ++i)
    {
      if (formats[i].format == hdrFormat &&
          formats[i].colorSpace == hdrColorSpace)
      {
        formatIndex = i;
        break;
      }
    }
    if (formatIndex == UINT32_MAX)
    {
      DEBUG_WARN("Could not find suitable surface format; HDR content will look bad");
    }
  }

  if (formatIndex == UINT32_MAX)
  {
    for (uint32_t i = 0; i < formatCount; ++i)
    {
      if ((formats[i].format == VK_FORMAT_R8G8B8A8_UNORM || formats[i].format == VK_FORMAT_B8G8R8A8_UNORM) &&
          formats[i].colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR)
      {
        formatIndex = i;
        break;
      }
    }
  }

  if (formatIndex == UINT32_MAX)
  {
    DEBUG_ERROR("Could not find any suitable surface format");
    goto err_formats;
  }

  format = formats[formatIndex];
  free(formats);
  return format;

err_formats:
  free(formats);

err:
  return format;
}

static bool vulkan_createSwapchain(struct Inst * this,
    VkSurfaceFormatKHR surfaceFormat)
{
  vulkan_freeSwapchain(this);

  VkSurfaceCapabilitiesKHR surfaceCaps;
  VkResult result = vkGetPhysicalDeviceSurfaceCapabilitiesKHR(
      this->physicalDevice, this->surface, &surfaceCaps);
  if (result != VK_SUCCESS)
  {
    DEBUG_ERROR("Failed to get surface capabilities (VkResult: %d)", result);
    goto err;
  }

  VkCompositeAlphaFlagBitsKHR compositeAlpha;
  if (surfaceCaps.supportedCompositeAlpha & VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR)
    compositeAlpha = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR;
  else if (surfaceCaps.supportedCompositeAlpha & VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR)
    compositeAlpha = VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR;
  else if (surfaceCaps.supportedCompositeAlpha & VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR)
    compositeAlpha = VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR;
  else if (surfaceCaps.supportedCompositeAlpha & VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
    compositeAlpha = VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR;
  else
    DEBUG_FATAL("No supported composite alpha mode");

  uint32_t modeCount;
  result = vkGetPhysicalDeviceSurfacePresentModesKHR(this->physicalDevice,
      this->surface, &modeCount, NULL);
  if (result != VK_SUCCESS)
  {
    DEBUG_ERROR("Failed to get surface present modes (VkResult: %d)", result);
    goto err;
  }

  VkPresentModeKHR * modes = malloc(sizeof(VkPresentModeKHR) * modeCount);
  if (!modes)
  {
    DEBUG_ERROR("out of memory");
    goto err;
  }

  result = vkGetPhysicalDeviceSurfacePresentModesKHR(this->physicalDevice,
      this->surface, &modeCount, modes);
  if (result != VK_SUCCESS)
  {
    DEBUG_ERROR("Failed to get surface present modes (VkResult: %d)", result);
    goto err_modes;
  }

  VkPresentModeKHR presentMode = VK_PRESENT_MODE_FIFO_KHR;
  for (uint32_t i = 0; i < modeCount; ++i)
  {
    if (modes[i] == VK_PRESENT_MODE_MAILBOX_KHR)
    {
      presentMode = VK_PRESENT_MODE_MAILBOX_KHR;
      break;
    }
  }

  struct VkSwapchainCreateInfoKHR createInfo =
  {
    .sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR,
    .surface = this->surface,
    .minImageCount = surfaceCaps.minImageCount,
    .imageFormat = surfaceFormat.format,
    .imageColorSpace = surfaceFormat.colorSpace,
    .imageExtent.width = this->width,
    .imageExtent.height = this->height,
    .imageArrayLayers = 1,
    .imageUsage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT |
        VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT,
    .imageSharingMode = VK_SHARING_MODE_EXCLUSIVE,
    .preTransform = surfaceCaps.currentTransform,
    .compositeAlpha = compositeAlpha,
    .presentMode = presentMode,
    .clipped = VK_TRUE
  };

  DEBUG_INFO("Min image count: %"PRIu32, createInfo.minImageCount);
  DEBUG_INFO("Image format   : %d", createInfo.imageFormat);
  DEBUG_INFO("Color space    : %d", createInfo.imageColorSpace);
  DEBUG_INFO("Extent         : %"PRIu32"x%"PRIu32,
      createInfo.imageExtent.width, createInfo.imageExtent.height);
  DEBUG_INFO("Pre-transform  : %d", createInfo.preTransform);
  DEBUG_INFO("Composite alpha: %d", createInfo.compositeAlpha);
  DEBUG_INFO("Present mode   : %d", createInfo.presentMode);

  result = vkCreateSwapchainKHR(this->device, &createInfo, NULL,
      &this->swapchain);
  if (result != VK_SUCCESS)
  {
    DEBUG_ERROR("Failed to create swapchain (VkResult: %d)", result);
    goto err_modes;
  }
  this->swapchainFormat = createInfo.imageFormat;
  this->swapchainExtent = createInfo.imageExtent;

  if (this->vkSetHdrMetadataEXT)
  {
    struct VkHdrMetadataEXT hdrMetadata =
    {
      .sType = VK_STRUCTURE_TYPE_HDR_METADATA_EXT,
      .displayPrimaryRed.x = this->format.colorMetadata.redPrimaryX,
      .displayPrimaryRed.y = this->format.colorMetadata.redPrimaryY,
      .displayPrimaryGreen.x = this->format.colorMetadata.greenPrimaryX,
      .displayPrimaryGreen.y = this->format.colorMetadata.greenPrimaryY,
      .displayPrimaryBlue.x = this->format.colorMetadata.bluePrimaryX,
      .displayPrimaryBlue.y = this->format.colorMetadata.bluePrimaryY,
      .whitePoint.x = this->format.colorMetadata.whitePointX,
      .whitePoint.y = this->format.colorMetadata.whitePointY,
      .maxLuminance = this->format.colorMetadata.maxLuminance,
      .minLuminance = this->format.colorMetadata.minLuminance,
      .maxContentLightLevel = this->format.colorMetadata.maxLuminance,
      .maxFrameAverageLightLevel = this->format.colorMetadata.maxFullFrameLuminance
    };

    this->vkSetHdrMetadataEXT(this->device, 1, &this->swapchain, &hdrMetadata);
  }

  free(modes);
  return true;

err_modes:
  free(modes);

err:
  return false;
}

static bool vulkan_createRenderPass(struct Inst * this)
{
  if (this->renderPass)
  {
    vkDestroyRenderPass(this->device, this->renderPass, NULL);
    this->renderPass = NULL;
  }

  struct VkAttachmentDescription attachments[] =
  {
    // Swapchain image
    {
      .format = this->swapchainFormat,
      .samples = VK_SAMPLE_COUNT_1_BIT,
      .loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR,
      .storeOp = VK_ATTACHMENT_STORE_OP_STORE,
      .stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE,
      .stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE,
      .initialLayout = VK_IMAGE_LAYOUT_UNDEFINED,
      .finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR
    },
    // ImGui render target
    {
      .format = VK_FORMAT_B8G8R8A8_UNORM,
      .samples = VK_SAMPLE_COUNT_1_BIT,
      .loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR,
      .storeOp = VK_ATTACHMENT_STORE_OP_DONT_CARE,
      .stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE,
      .stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE,
      .initialLayout = VK_IMAGE_LAYOUT_UNDEFINED,
      .finalLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL
    }
  };

  struct VkAttachmentReference imGuiColorAttachments[] =
  {
    {
      .attachment = 1,
      .layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL
    }
  };

  struct VkAttachmentReference mainInputAttachments[] =
  {
    {
      .attachment = 0,
      .layout = VK_IMAGE_LAYOUT_GENERAL
    },
    {
      .attachment = 1,
      .layout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL
    }
  };

  struct VkAttachmentReference mainColorAttachments[] =
  {
    {
      .attachment = 0,
      .layout = VK_IMAGE_LAYOUT_GENERAL
    }
  };

  struct VkSubpassDescription subpasses[] = {
    // ImGUI subpass
    {
      .pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS,
      .colorAttachmentCount = ARRAY_LENGTH(imGuiColorAttachments),
      .pColorAttachments = imGuiColorAttachments
    },
    // Main subpass
    {
      .pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS,
      .inputAttachmentCount = ARRAY_LENGTH(mainInputAttachments),
      .pInputAttachments = mainInputAttachments,
      .colorAttachmentCount = ARRAY_LENGTH(mainColorAttachments),
      .pColorAttachments = mainColorAttachments
    }
  };

  struct VkSubpassDependency dependencies[] =
  {
    {
      .srcSubpass = VK_SUBPASS_EXTERNAL,
      .dstSubpass = 0,
      .srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,
      .dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,
      .srcAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT,
      .dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT
    },
    {
      .srcSubpass = 0,
      .dstSubpass = 1,
      .srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,
      .dstStageMask = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,
      .srcAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT,
      .dstAccessMask = VK_ACCESS_INPUT_ATTACHMENT_READ_BIT,
      .dependencyFlags = VK_DEPENDENCY_BY_REGION_BIT
    },
    // This self-dependency allows us to insert pipeline barriers within the
    // render pass, enabling programmatic blending
    {
      .srcSubpass = 1,
      .dstSubpass = 1,
      .srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,
      .dstStageMask = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,
      .srcAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT,
      .dstAccessMask = VK_ACCESS_INPUT_ATTACHMENT_READ_BIT,
      .dependencyFlags = VK_DEPENDENCY_BY_REGION_BIT
    }
  };

  struct VkRenderPassCreateInfo createInfo =
  {
    .sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO,
    .attachmentCount = ARRAY_LENGTH(attachments),
    .pAttachments = attachments,
    .subpassCount = ARRAY_LENGTH(subpasses),
    .pSubpasses = subpasses,
    .dependencyCount = ARRAY_LENGTH(dependencies),
    .pDependencies = dependencies
  };

  VkResult result = vkCreateRenderPass(this->device, &createInfo, NULL,
      &this->renderPass);
  if (result != VK_SUCCESS)
  {
    DEBUG_ERROR("Failed to create render pass (VkResult: %d)", result);
    return false;
  }

  return true;
}

static bool vulkan_createDesktopPipeline(struct Inst * this)
{
  if (this->pipeline)
  {
    vkDestroyPipeline(this->device, this->pipeline, NULL);
    this->pipeline = NULL;
  }

  this->pipeline = vulkan_createGraphicsPipeline(this->device,
      this->transformTextureVertexShader, this->fragmentShader, NULL,
      this->pipelineLayout, this->renderPass);
  if (!this->pipeline)
    return false;

  return true;
}

static bool vulkan_createImGuiImage(struct Inst * this)
{
  vulkan_freeImGuiImage(this);

  struct VkImageCreateInfo createInfo =
  {
    .sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
    .imageType = VK_IMAGE_TYPE_2D,
    .format = VK_FORMAT_B8G8R8A8_UNORM,
    .extent.width = this->swapchainExtent.width,
    .extent.height = this->swapchainExtent.height,
    .extent.depth = 1,
    .mipLevels = 1,
    .arrayLayers = 1,
    .samples = VK_SAMPLE_COUNT_1_BIT,
    .tiling = VK_IMAGE_TILING_OPTIMAL,
    .usage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT |
        VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT,
    .sharingMode = VK_SHARING_MODE_EXCLUSIVE,
    .initialLayout = VK_IMAGE_LAYOUT_UNDEFINED
  };

  VkResult result = vkCreateImage(this->device, &createInfo, NULL,
      &this->imGuiImage);
  if (result != VK_SUCCESS)
  {
    DEBUG_ERROR("Failed to create ImGui image (VkResult: %d)", result);
    goto err;
  }

  struct VkMemoryRequirements memoryRequirements;
  vkGetImageMemoryRequirements(this->device, this->imGuiImage,
      &memoryRequirements);

  this->imGuiImageMemory = vulkan_allocateMemory(&this->memoryProperties,
      this->device, &memoryRequirements, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT);
  if (!this->imGuiImageMemory)
    goto err_image;

  result = vkBindImageMemory(this->device, this->imGuiImage,
      this->imGuiImageMemory, 0);
  if (result != VK_SUCCESS)
  {
    DEBUG_ERROR("Failed to bind ImGui image memory (VkResult: %d)", result);
    goto err_memory;
  }

  this->imGuiImageView = vulkan_createImageView(this->device,
      this->imGuiImage, createInfo.format);
  if (!this->imGuiImageView)
    goto err_memory;

  return true;

err_memory:
  vkFreeMemory(this->device, this->imGuiImageMemory, NULL);
  this->imGuiImageMemory = NULL;

err_image:
  vkDestroyImage(this->device, this->imGuiImage, NULL);
  this->imGuiImage = NULL;

err:
  return false;
}

static bool vulkan_createFramebuffers(struct Inst * this)
{
  vulkan_freeFramebuffers(this);

  this->framebuffers = calloc(this->swapchainImageCount, sizeof(VkFramebuffer));
  if (!this->framebuffers)
  {
    DEBUG_ERROR("out of memory");
    goto err;
  }

  for (uint32_t i = 0; i < this->swapchainImageCount; ++i)
  {
    VkImageView attachments[] = {
      this->swapchainImageViews[i],
      this->imGuiImageView
    };

    struct VkFramebufferCreateInfo createInfo =
    {
      .sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO,
      .renderPass = this->renderPass,
      .attachmentCount = ARRAY_LENGTH(attachments),
      .pAttachments = attachments,
      .width = this->swapchainExtent.width,
      .height = this->swapchainExtent.height,
      .layers = 1
    };

    VkResult result = vkCreateFramebuffer(this->device, &createInfo, NULL,
        &this->framebuffers[i]);
    if (result != VK_SUCCESS)
    {
      DEBUG_ERROR("Failed to create framebuffer (VkResult: %d)", result);
      goto err_framebuffers;
    }
  }

  return true;

err_framebuffers:
  vulkan_freeFramebuffers(this);

err:
  return false;
}

static VkFormat vulkan_selectDesktopImageFormat(struct Inst * this)
{
  switch (this->format.type)
  {
    case FRAME_TYPE_BGRA:
      return VK_FORMAT_B8G8R8A8_UNORM;
    case FRAME_TYPE_RGBA:
      return VK_FORMAT_R8G8B8A8_UNORM;
    case FRAME_TYPE_RGBA10:
      return VK_FORMAT_A2B10G10R10_UNORM_PACK32;
    case FRAME_TYPE_RGBA16F:
      return VK_FORMAT_R16G16B16A16_SFLOAT;
    case FRAME_TYPE_BGR_32:
      DEBUG_FATAL("FRAME_TYPE_BGR_32 not implemented");
    case FRAME_TYPE_RGB_24:
      DEBUG_FATAL("FRAME_TYPE_RGB_24 not implemented");
    default:
      DEBUG_FATAL("Could not determine Vulkan format for frame type %d",
          this->format.type);
  }
}

static bool vulkan_createDesktopImage(struct Inst * this, VkFormat format)
{
  vulkan_freeDesktopImage(this);

  struct VkImageCreateInfo createInfo =
  {
    .sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
    .pNext = NULL,
    .flags = 0,
    .imageType = VK_IMAGE_TYPE_2D,
    .format = format,
    .extent.width = this->format.frameWidth,
    .extent.height = this->format.frameHeight,
    .extent.depth = 1,
    .mipLevels = 1,
    .arrayLayers = 1,
    .samples = VK_SAMPLE_COUNT_1_BIT,
    .tiling = VK_IMAGE_TILING_LINEAR,
    .usage = VK_IMAGE_USAGE_SAMPLED_BIT,
    .sharingMode = VK_SHARING_MODE_EXCLUSIVE,
    .queueFamilyIndexCount = 0,
    .pQueueFamilyIndices = NULL,
    .initialLayout = VK_IMAGE_LAYOUT_PREINITIALIZED
  };

  VkResult result = vkCreateImage(this->device, &createInfo, NULL,
      &this->desktopImage);
  if (result != VK_SUCCESS)
  {
    DEBUG_ERROR("Failed to create desktop image (VkResult: %d)", result);
    goto err;
  }

  struct VkMemoryRequirements memoryRequirements;
  vkGetImageMemoryRequirements(this->device, this->desktopImage,
      &memoryRequirements);

  this->desktopImageMemory = vulkan_allocateMemory(&this->memoryProperties,
      this->device, &memoryRequirements,
      VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT |
      VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |
      VK_MEMORY_PROPERTY_HOST_COHERENT_BIT);
  if (!this->desktopImageMemory)
    goto err_image;

  result = vkBindImageMemory(this->device, this->desktopImage,
      this->desktopImageMemory, 0);
  if (result != VK_SUCCESS)
  {
    DEBUG_ERROR("Failed to bind desktop image memory (VkResult: %d)", result);
    goto err_memory;
  }

  result = vkMapMemory(this->device, this->desktopImageMemory, 0, VK_WHOLE_SIZE,
      0, &this->desktopImageMap);
  if (result != VK_SUCCESS)
  {
    DEBUG_ERROR("Failed to map desktop image memory (VkResult: %d)", result);
    goto err_memory;
  }

  memset(this->desktopImageMap, 0, memoryRequirements.size);

  this->desktopImageView = vulkan_createImageView(this->device,
      this->desktopImage, createInfo.format);
  if (!this->desktopImageView)
    goto err_memory_map;

  VkImageSubresource subresource =
  {
    .aspectMask = VK_IMAGE_ASPECT_COLOR_BIT,
    .mipLevel = 0,
    .arrayLayer = 0
  };
  VkSubresourceLayout subresourceLayout;
  vkGetImageSubresourceLayout(this->device, this->desktopImage, &subresource,
      &subresourceLayout);

  this->desktopImagePitch = subresourceLayout.rowPitch;
  this->desktopImageLayout = createInfo.initialLayout;
  this->desktopFormat = createInfo.format;
  this->desktopExtent.width = createInfo.extent.width;
  this->desktopExtent.height = createInfo.extent.height;
  return true;

err_memory_map:
  vkUnmapMemory(this->device, this->desktopImageMemory);
  this->desktopImageMap = NULL;

err_memory:
  vkFreeMemory(this->device, this->desktopImageMemory, NULL);
  this->desktopImageMemory = NULL;

err_image:
  vkDestroyImage(this->device, this->desktopImage, NULL);
  this->desktopImage = NULL;

err:
  return false;
}

static bool vulkan_initPipeline(struct Inst * this)
{
  VkSurfaceFormatKHR surfaceFormat = vulkan_selectSurfaceFormat(this);
  if (surfaceFormat.format == VK_FORMAT_UNDEFINED)
    goto err;

  bool surfaceFormatChanged = surfaceFormat.format != this->swapchainFormat;
  bool surfaceSizeChanged = this->width != this->swapchainExtent.width ||
      this->height != this->swapchainExtent.height;

  if (surfaceFormatChanged || surfaceSizeChanged)
  {
    ShaderColorSpace colorSpace;
    switch (surfaceFormat.colorSpace)
    {
      case VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT:
        colorSpace = SHADER_COLOR_SPACE_EXTENDED_SRGB_LINEAR;
        break;
      case VK_COLOR_SPACE_HDR10_ST2084_EXT:
        colorSpace = SHADER_COLOR_SPACE_HDR10_ST2084;
        break;
      default:
        colorSpace = SHADER_COLOR_SPACE_SRGB;
    }

    if (!vulkan_createSwapchain(this, surfaceFormat))
      goto err;

    if (!vulkan_getSwapchainImages(this))
      goto err_swapchain;

    if (surfaceFormatChanged)
    {
      if (!vulkan_createRenderPass(this))
        goto err_swapchain;

      if (!vulkan_createDesktopPipeline(this))
        goto err_render_pass;

      if (!vulkan_cursorInitPipeline(this->cursor, this->renderPass,
          colorSpace))
        goto err_pipeline;

      if (!vulkan_imGuiInitPipeline(this->imGui, this->swapchainImageCount,
          this->renderPass, colorSpace))
        goto err_pipeline;
    }

    if (surfaceSizeChanged)
    {
      if (!vulkan_createImGuiImage(this))
        goto err_imgui;
    }

    if (!vulkan_createFramebuffers(this))
      goto err_imgui_image;
  }

  if (this->format.type == FRAME_TYPE_INVALID)
    vulkan_freeDesktopImage(this);
  else
  {
    VkFormat desktopFormat = vulkan_selectDesktopImageFormat(this);

    bool desktopFormatChanged = desktopFormat != this->desktopFormat;
    bool desktopSizeChanged =
        this->format.frameWidth != this->desktopExtent.width ||
        this->format.frameHeight != this->desktopExtent.height;

    if (desktopFormatChanged || desktopSizeChanged)
    {
      if (!vulkan_createDesktopImage(this, desktopFormat))
        goto err_framebuffers;

      vulkan_updateDescriptorSet1(this->device, this->descriptorSets[1],
          this->desktopUniformBuffer, this->desktopImageView,
          VK_IMAGE_LAYOUT_GENERAL);
    }
  }

  if (!vulkan_imGuiUploadFonts(this->imGui))
    goto err_desktop_image;

  return true;

err_desktop_image:
  vulkan_freeDesktopImage(this);

err_framebuffers:
  vulkan_freeFramebuffers(this);

err_imgui_image:
  vulkan_freeImGuiImage(this);

err_imgui:
  vulkan_imGuiDeinitPipeline(this->imGui);

err_pipeline:
  vkDestroyPipeline(this->device, this->pipeline, NULL);
  this->pipeline = NULL;

err_render_pass:
  vkDestroyRenderPass(this->device, this->renderPass, NULL);
  this->renderPass = NULL;
  
err_swapchain:
  vulkan_freeSwapchain(this);

err:
  return false;
}

static void vulkan_calc_mouse_size(struct Inst * this)
{
  if (!this->formatValid)
    return;

  switch(this->format.rotate)
  {
    case LG_ROTATE_0:
    case LG_ROTATE_180:
      this->mouseScaleX = 2.0f / this->format.screenWidth;
      this->mouseScaleY = 2.0f / this->format.screenHeight;
      break;

    case LG_ROTATE_90:
    case LG_ROTATE_270:
      this->mouseScaleX = 2.0f / this->format.screenHeight;
      this->mouseScaleY = 2.0f / this->format.screenWidth;
      break;

    default:
      DEBUG_UNREACHABLE();
  }
}

static void vulkan_calc_mouse_state(struct Inst * this)
{
  if (!this->formatValid)
    return;

  switch((this->format.rotate + this->rotate) % LG_ROTATE_MAX)
  {
    case LG_ROTATE_0:
    case LG_ROTATE_180:
      vulkan_cursorSetState(
        this->cursor,
        this->cursorVisible,
        (((float)this->cursorX  * this->mouseScaleX) - 1.0f) * this->scaleX,
        (((float)this->cursorY  * this->mouseScaleY) - 1.0f) * this->scaleY,
        ((float)this->cursorHX * this->mouseScaleX) * this->scaleX,
        ((float)this->cursorHY * this->mouseScaleY) * this->scaleY
      );
      break;

    case LG_ROTATE_90:
    case LG_ROTATE_270:
      vulkan_cursorSetState(
        this->cursor,
        this->cursorVisible,
        (((float)this->cursorX  * this->mouseScaleX) - 1.0f) * this->scaleY,
        (((float)this->cursorY  * this->mouseScaleY) - 1.0f) * this->scaleX,
        ((float)this->cursorHX * this->mouseScaleX) * this->scaleY,
        ((float)this->cursorHY * this->mouseScaleY) * this->scaleX
      );
      break;
  }
}

static bool vulkan_onResize(LG_Renderer * renderer, const int width,
    const int height, const double scale, const LG_RendererRect destRect,
    LG_RendererRotate rotate)
{
  struct Inst * this = UPCAST(struct Inst, renderer);

  this->width   = width * scale;
  this->height  = height * scale;
  this->rotate  = rotate;

  this->destRect.x = destRect.x * scale;
  this->destRect.y = destRect.y * scale;
  this->destRect.w = destRect.w * scale;
  this->destRect.h = destRect.h * scale;

  if (destRect.valid)
  {
    this->translateX     = -1.0f + (((this->destRect.w / 2) + this->destRect.x) * 2) / (float)this->width;
    this->translateY     = -1.0f + (((this->destRect.h / 2) + this->destRect.y) * 2) / (float)this->height;
    this->scaleX         = (float)this->destRect.w / (float)this->width;
    this->scaleY         = (float)this->destRect.h / (float)this->height;
  }

  if (!vulkan_initPipeline(this))
    return false;

  vulkan_calc_mouse_size(this);
  vulkan_calc_mouse_state(this);

  return true;
}

static bool vulkan_onMouseShape(LG_Renderer * renderer,
    const LG_RendererCursor cursor, const int width, const int height,
    const int pitch, const uint8_t * data)
{
  struct Inst * this = UPCAST(struct Inst, renderer);

  if (!vulkan_cursorSetShape(this->cursor, cursor, width, height, pitch, data))
  {
    DEBUG_ERROR("Failed to update the cursor shape");
    return false;
  }

  this->mouseWidth  = width;
  this->mouseHeight = height;
  vulkan_calc_mouse_size(this);

  return true;
}

static bool vulkan_onMouseEvent(LG_Renderer * renderer, const bool visible,
    int x, int y, const int hx, const int hy)
{
  struct Inst * this = UPCAST(struct Inst, renderer);
  this->cursorVisible = visible;
  this->cursorX       = x + hx;
  this->cursorY       = y + hy;
  this->cursorHX      = hx;
  this->cursorHY      = hy;
  vulkan_calc_mouse_state(this);
  return true;
}

static bool vulkan_onFrameFormat(LG_Renderer * renderer,
    const LG_RendererFormat format)
{
  struct Inst * this = UPCAST(struct Inst, renderer);
  memcpy(&this->format, &format, sizeof(LG_RendererFormat));
  this->formatValid = true;

  if (!vulkan_initPipeline(this))
    goto err;

  return true;

err:
  return false;
}

static bool vulkan_onFrame(LG_Renderer * renderer, const FrameBuffer * frame,
    int dmaFd, const FrameDamageRect * damageRects, int damageRectsCount)
{
  struct Inst * this = UPCAST(struct Inst, renderer);

  if (!framebuffer_read(frame, this->desktopImageMap, this->desktopImagePitch,
      this->desktopExtent.height, this->desktopExtent.width, this->format.bpp,
      this->format.pitch))
  {
    DEBUG_ERROR("Failed to read from frame buffer");
    return false;
  }

  return true;
}

static VkInstance vulkan_createInstance(void)
{
  uint32_t enabledExtensionCount;
  const char ** extensions = vulkan_checkInstanceExtensions(
      &enabledExtensionCount);
  if (!extensions)
    goto err;

  struct VkApplicationInfo appInfo =
  {
    .sType = VK_STRUCTURE_TYPE_APPLICATION_INFO,
    .pApplicationName = "Looking Glass",
    .apiVersion = VK_API_VERSION_1_0
  };

  struct VkInstanceCreateInfo createInfo =
  {
    .sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
    .pApplicationInfo = &appInfo,
    .enabledExtensionCount = enabledExtensionCount,
    .ppEnabledExtensionNames = extensions
  };

  VkInstance instance;
  VkResult result = vkCreateInstance(&createInfo, NULL, &instance);
  if (result != VK_SUCCESS)
  {
    DEBUG_ERROR("Failed to create Vulkan instance (VkResult: %d)", result);
    goto err_extensions;
  }

  free(extensions);
  return instance;

err_extensions:
  free(extensions);

err:
  return NULL;
}

static bool vulkan_pickPhysicalDevice(struct Inst * this)
{
  uint32_t deviceCount;
  VkResult result = vkEnumeratePhysicalDevices(this->instance, &deviceCount,
      NULL);
  if (result != VK_SUCCESS)
  {
    DEBUG_ERROR("Failed to enumerate physical devices (VkResult: %d)", result);
    goto err;
  }
  if (deviceCount == 0)
  {
    DEBUG_ERROR("No Vulkan devices available");
    goto err;
  }

  VkPhysicalDevice * devices = malloc(sizeof(VkPhysicalDevice) * deviceCount);
  if (!devices)
  {
    DEBUG_ERROR("out of memory");
    goto err;
  }

  result = vkEnumeratePhysicalDevices(this->instance, &deviceCount, devices);
  if (result != VK_SUCCESS)
  {
    DEBUG_ERROR("Failed to enumerate physical devices (VkResult: %d)", result);
    goto err_devices;
  }

  this->queueFamilyIndex = UINT32_MAX;
  for (uint32_t i = 0; i < deviceCount; ++i)
  {
    uint32_t queueFamilyCount;
    vkGetPhysicalDeviceQueueFamilyProperties(devices[i], &queueFamilyCount,
        NULL);

    VkQueueFamilyProperties * queueFamilyProperties = malloc(
        sizeof(VkQueueFamilyProperties) * queueFamilyCount);
    if (!queueFamilyProperties)
    {
      DEBUG_ERROR("out of memory");
      goto err_devices;
    }

    vkGetPhysicalDeviceQueueFamilyProperties(devices[i], &queueFamilyCount,
        queueFamilyProperties);

    this->queueFamilyIndex = UINT32_MAX;
    for (uint32_t j = 0; j < queueFamilyCount; ++j)
    {
      if (queueFamilyProperties[j].queueFlags & VK_QUEUE_GRAPHICS_BIT)
      {
        this->queueFamilyIndex = j;
        break;
      }
    }
    free(queueFamilyProperties);
    if (this->queueFamilyIndex == UINT32_MAX)
      continue;

    this->physicalDevice = devices[i];
    break;
  }
  if (this->physicalDevice == NULL)
  {
    DEBUG_ERROR("Could not find any usable Vulkan device");
    goto err_devices;
  }

  VkPhysicalDeviceProperties properties;
  vkGetPhysicalDeviceProperties(this->physicalDevice, &properties);

  DEBUG_INFO("Device      : %s", properties.deviceName);
  DEBUG_INFO("Queue family: %"PRIu32, this->queueFamilyIndex);

  vkGetPhysicalDeviceMemoryProperties(this->physicalDevice,
      &this->memoryProperties);

  free(devices);
  return true;

err_devices:
  free(devices);

err:
  return false;
}

static void vulkan_getDeviceMethods(struct Inst * this)
{
  this->vkSetHdrMetadataEXT = (PFN_vkSetHdrMetadataEXT)
      vkGetDeviceProcAddr(this->device, "vkSetHdrMetadataEXT");
}

static bool vulkan_createDevice(struct Inst * this)
{
  uint32_t enabledExtensionCount;
  const char ** extensions = vulkan_checkDeviceExtensions(this->physicalDevice,
      &enabledExtensionCount);
  if (!extensions)
    goto err;

  float queuePriority = 1.0f;

  struct VkDeviceQueueCreateInfo queueCreateInfo =
  {
    .sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,
    .queueFamilyIndex = this->queueFamilyIndex,
    .queueCount = 1,
    .pQueuePriorities = &queuePriority
  };

  struct VkDeviceCreateInfo createInfo =
  {
    .sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
    .queueCreateInfoCount = 1,
    .pQueueCreateInfos = &queueCreateInfo,
    .enabledExtensionCount = enabledExtensionCount,
    .ppEnabledExtensionNames = extensions
  };

  VkResult result = vkCreateDevice(this->physicalDevice, &createInfo, NULL,
      &this->device);
  if (result != VK_SUCCESS)
  {
    DEBUG_ERROR("Failed to create Vulkan device (VkResult: %d)", result);
    goto err_extensions;
  }

  vulkan_getDeviceMethods(this);

  vkGetDeviceQueue(this->device, this->queueFamilyIndex, 0, &this->queue);

  free(extensions);
  return true;

err_extensions:
  free(extensions);

err:
  return false;
}

static bool vulkan_createCommandPool(struct Inst * this)
{
  struct VkCommandPoolCreateInfo createInfo =
  {
    .sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO,
    .flags = VK_COMMAND_POOL_CREATE_TRANSIENT_BIT |
        VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT,
    .queueFamilyIndex = this->queueFamilyIndex
  };

  VkResult result = vkCreateCommandPool(this->device, &createInfo, NULL,
      &this->commandPool);
  if (result != VK_SUCCESS)
  {
    DEBUG_ERROR("Failed to create command pool (VkResult: %d)", result);
    return false;
  }

  return true;
}

static bool vulkan_allocateCommandBuffer(struct Inst * this)
{
  struct VkCommandBufferAllocateInfo allocateInfo =
  {
    .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO,
    .commandPool = this->commandPool,
    .level = VK_COMMAND_BUFFER_LEVEL_PRIMARY,
    .commandBufferCount = 1
  };

  VkResult result = vkAllocateCommandBuffers(this->device, &allocateInfo,
      &this->commandBuffer);
  if (result != VK_SUCCESS)
  {
    DEBUG_ERROR("Failed to allocate command buffer (VkResult: %d)", result);
    return false;
  }

  return true;
}

static bool vulkan_createSampler(struct Inst * this)
{
  struct VkSamplerCreateInfo createInfo =
  {
    .sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO,
    .magFilter = VK_FILTER_LINEAR,
    .minFilter = VK_FILTER_LINEAR,
    .addressModeU = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER,
    .addressModeV = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER,
    .addressModeW = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER,
    .borderColor = VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK
  };

  VkResult result = vkCreateSampler(this->device, &createInfo, NULL,
      &this->sampler);
  if (result != VK_SUCCESS)
  {
    DEBUG_ERROR("Failed to create sampler (VkResult: %d)", result);
    return false;
  }

  return true;
}

static bool vulkan_createDescriptorSetLayout0(struct Inst * this)
{
  struct VkDescriptorSetLayoutBinding bindings[] =
  {
    // Swapchain image
    {
      .binding = 0,
      .descriptorType = VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT,
      .descriptorCount = 1,
      .stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT
    },
    // ImGui render target
    {
      .binding = 1,
      .descriptorType = VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT,
      .descriptorCount = 1,
      .stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT
    }
  };

  struct VkDescriptorSetLayoutCreateInfo createInfo =
  {
    .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
    .bindingCount = ARRAY_LENGTH(bindings),
    .pBindings = bindings
  };

  VkResult result = vkCreateDescriptorSetLayout(this->device, &createInfo, NULL,
      &this->descriptorSetLayouts[0]);
  if (result != VK_SUCCESS)
  {
    DEBUG_ERROR("Failed to create descriptor set layout 0 (VkResult: %d)",
        result);
    return false;
  }

  return true;
}

static bool vulkan_createDescriptorSetLayout1(struct Inst * this)
{
  struct VkDescriptorSetLayoutBinding bindings[] =
  {
    {
      .binding = 0,
      .descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
      .descriptorCount = 1,
      .stageFlags = VK_SHADER_STAGE_VERTEX_BIT
    },
    {
      .binding = 1,
      .descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
      .descriptorCount = 1,
      .stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT,
      .pImmutableSamplers = &this->sampler
    }
  };

  struct VkDescriptorSetLayoutCreateInfo createInfo =
  {
    .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
    .bindingCount = ARRAY_LENGTH(bindings),
    .pBindings = bindings
  };

  VkResult result = vkCreateDescriptorSetLayout(this->device, &createInfo, NULL,
      &this->descriptorSetLayouts[1]);
  if (result != VK_SUCCESS)
  {
    DEBUG_ERROR("Failed to create descriptor set layout 1 (VkResult: %d)",
        result);
    return false;
  }

  return true;
}

static bool vulkan_createDescriptorPool(struct Inst * this)
{
  struct VkDescriptorPoolSize poolSizes[] =
  {
    {
      .type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
      .descriptorCount = 2
    },
    {
      .type = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
      .descriptorCount = 8
    },
    {
      .type = VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT,
      .descriptorCount = 2
    }
  };

  struct VkDescriptorPoolCreateInfo createInfo =
  {
    .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO,
    .flags = VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT,
    .maxSets = 8,
    .poolSizeCount = ARRAY_LENGTH(poolSizes),
    .pPoolSizes = poolSizes
  };

  VkResult result = vkCreateDescriptorPool(this->device, &createInfo, NULL,
      &this->descriptorPool);
  if (result != VK_SUCCESS)
  {
    DEBUG_ERROR("Failed to create descriptor pool (VkResult: %d)",
        result);
    return false;
  }

  return true;
}

static bool vulkan_createPipelineLayout(struct Inst * this)
{
  struct VkPipelineLayoutCreateInfo createInfo =
  {
    .sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
    .setLayoutCount = ARRAY_LENGTH(this->descriptorSetLayouts),
    .pSetLayouts = this->descriptorSetLayouts
  };

  VkResult result = vkCreatePipelineLayout(this->device, &createInfo, NULL,
      &this->pipelineLayout);
  if (result != VK_SUCCESS)
  {
    DEBUG_ERROR("Failed to create pipeline layout (VkResult: %d)", result);
    return false;
  }

  return true;
}

static bool vulkan_createSemaphore(struct Inst * this, VkSemaphore *semaphore)
{
  struct VkSemaphoreCreateInfo createInfo =
  {
    .sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO
  };

  VkResult result = vkCreateSemaphore(this->device, &createInfo, NULL,
      semaphore);
  if (result != VK_SUCCESS)
  {
    DEBUG_ERROR("Failed to create semaphore (VkResult: %d)", result);
    return false;
  }

  return true;
}

static bool vulkan_createFence(struct Inst * this)
{
  struct VkFenceCreateInfo createInfo =
  {
    .sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO
  };

  VkResult result = vkCreateFence(this->device, &createInfo, NULL,
      &this->fence);
  if (result != VK_SUCCESS)
  {
    DEBUG_ERROR("Failed to create fence (VkResult: %d)", result);
    return false;
  }

  return true;
}

static bool vulkan_createDesktopUniformBuffer(struct Inst * this)
{
  this->desktopUniformBuffer = vulkan_createBuffer(&this->memoryProperties,
      this->device, sizeof(struct VulkanUniformBuffer),
      VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT, &this->desktopUniformBufferMemory,
      &this->desktopUniformBufferMap);
  if (!this->desktopUniformBuffer)
    return false;

  return true;
}

static bool vulkan_renderStartup(LG_Renderer * renderer, bool useDMA)
{
  struct Inst * this = UPCAST(struct Inst, renderer);

  this->instance = vulkan_createInstance();
  if (!this->instance)
    goto err;

  this->surface = app_createVulkanSurface(this->instance);
  if (!this->surface)
    goto err_inst;

  if (!vulkan_pickPhysicalDevice(this))
    goto err_surf;

  if (!vulkan_createDevice(this))
    goto err_surf;

  this->fullScreenVertexShader = vulkan_loadShader(this->device,
      b_shader_fullscreen_vert_spv,
      b_shader_fullscreen_vert_spv_size - 1);
  if (!this->fullScreenVertexShader)
    goto err_device;

  this->transformTextureVertexShader = vulkan_loadShader(this->device,
      b_shader_transform_texture_vert_spv,
      b_shader_transform_texture_vert_spv_size - 1);
  if (!this->transformTextureVertexShader)
    goto err_fullscreen_vert_shader;

  this->fragmentShader = vulkan_loadShader(this->device,
      b_shader_basic_frag_spv, b_shader_basic_frag_spv_size - 1);
  if (!this->fragmentShader)
    goto err_transform_texture_vert_shader;

  if (!vulkan_createCommandPool(this))
    goto err_frag_shader;

  if (!vulkan_allocateCommandBuffer(this))
    goto err_command_pool;

  if (!vulkan_createSampler(this))
    goto err_command_pool;

  if (!vulkan_createDescriptorSetLayout0(this))
    goto err_sampler;

  if (!vulkan_createDescriptorSetLayout1(this))
    goto err_descriptor_set_layout0;

  if (!vulkan_createDescriptorPool(this))
    goto err_descriptor_set_layout1;

  for (int i = 0; i < ARRAY_LENGTH(this->descriptorSetLayouts); ++i)
  {
    this->descriptorSets[i] = vulkan_allocateDescriptorSet(this->device,
        this->descriptorSetLayouts[i], this->descriptorPool);
    if (!this->descriptorSets[i])
      goto err_descriptor_set_layout1;
  }

  if (!vulkan_createPipelineLayout(this))
    goto err_descriptor_pool;

  if (!vulkan_createSemaphore(this, &this->swapchainAcquireSemaphore))
    goto err_pipeline_layout;

  if (!vulkan_createSemaphore(this, &this->swapchainReleaseSemaphore))
    goto err_swapchain_acq_sem;

  if (!vulkan_createFence(this))
    goto err_swapchain_rel_sem;

  if (!vulkan_createDesktopUniformBuffer(this))
    goto err_fence;

  if (!vulkan_cursorInit(&this->cursor, &this->memoryProperties, this->device,
      this->transformTextureVertexShader, this->commandBuffer,
      this->descriptorSetLayouts[1], this->descriptorPool,
      this->pipelineLayout))
    goto err_desktop_uniform;

  if (!vulkan_imGuiInit(&this->imGui, this->instance, this->physicalDevice,
      this->queueFamilyIndex, &this->memoryProperties, this->device,
      this->queue, this->fullScreenVertexShader, this->commandBuffer,
      this->sampler, this->descriptorPool, this->pipelineLayout, this->fence))
    goto err_cursor;

  return true;

err_cursor:
  vulkan_cursorFree(&this->cursor);

err_desktop_uniform:
  vkDestroyBuffer(this->device, this->desktopUniformBuffer, NULL);
  this->desktopUniformBuffer = NULL;

err_fence:
  vkDestroyFence(this->device, this->fence, NULL);
  this->fence = NULL;

err_swapchain_rel_sem:
  vkDestroySemaphore(this->device, this->swapchainReleaseSemaphore, NULL);
  this->swapchainReleaseSemaphore = NULL;

err_swapchain_acq_sem:
  vkDestroySemaphore(this->device, this->swapchainAcquireSemaphore, NULL);
  this->swapchainAcquireSemaphore = NULL;

err_pipeline_layout:
  vkDestroyPipelineLayout(this->device, this->pipelineLayout, NULL);
  this->pipelineLayout = NULL;

err_descriptor_pool:
  vkDestroyDescriptorPool(this->device, this->descriptorPool, NULL);
  this->descriptorPool = NULL;
  for (int i = 0; i < ARRAY_LENGTH(this->descriptorSets); ++i)
    this->descriptorSets[i] = NULL;

err_descriptor_set_layout1:
  vkDestroyDescriptorSetLayout(this->device, this->descriptorSetLayouts[1],
      NULL);
  this->descriptorSetLayouts[1] = NULL;

err_descriptor_set_layout0:
  vkDestroyDescriptorSetLayout(this->device, this->descriptorSetLayouts[0],
      NULL);
  this->descriptorSetLayouts[0] = NULL;

err_sampler:
  vkDestroySampler(this->device, this->sampler, NULL);
  this->sampler = NULL;

err_command_pool:
  vkDestroyCommandPool(this->device, this->commandPool, NULL);
  this->commandPool = NULL;
  this->commandBuffer = NULL;

err_frag_shader:
  vkDestroyShaderModule(this->device, this->fragmentShader, NULL);
  this->fragmentShader = NULL;

err_transform_texture_vert_shader:
  vkDestroyShaderModule(this->device, this->transformTextureVertexShader,
      NULL);
  this->transformTextureVertexShader = NULL;

err_fullscreen_vert_shader:
  vkDestroyShaderModule(this->device, this->fullScreenVertexShader, NULL);
  this->fullScreenVertexShader = NULL;

err_device:
  vkDestroyDevice(this->device, NULL);
  this->device = NULL;
  this->queue = NULL;

err_surf:
  vkDestroySurfaceKHR(this->instance, this->surface, NULL);
  this->surface = NULL;

err_inst:
  vkDestroyInstance(this->instance, NULL);
  this->instance = NULL;

err:
  return false;
}

static uint32_t vulkan_acquireSwapchainImage(struct Inst * this)
{
  uint32_t imageIndex;
  VkResult result = vkAcquireNextImageKHR(this->device, this->swapchain,
      UINT64_MAX, this->swapchainAcquireSemaphore, NULL, &imageIndex);
  if (result != VK_SUCCESS)
  {
    DEBUG_ERROR("Failed to acquire swapchain image (VkResult: %d)", result);
    return UINT32_MAX;
  }

  return imageIndex;
}

static void vulkan_preRenderBarrier(struct Inst * this)
{
  if (!this->desktopImage ||
      this->desktopImageLayout == VK_IMAGE_LAYOUT_GENERAL)
    return;

  struct VkImageMemoryBarrier desktopImageBarrier =
  {
    .sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,
    .pNext = NULL,
    .srcAccessMask = VK_ACCESS_NONE,
    .dstAccessMask = VK_ACCESS_SHADER_READ_BIT,
    .oldLayout = this->desktopImageLayout,
    .newLayout = VK_IMAGE_LAYOUT_GENERAL,
    .srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
    .dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
    .image = this->desktopImage,
    .subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT,
    .subresourceRange.baseMipLevel = 0,
    .subresourceRange.levelCount = 1,
    .subresourceRange.baseArrayLayer = 0,
    .subresourceRange.layerCount = 1
  };

  vkCmdPipelineBarrier(this->commandBuffer, VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,
      VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, 0, 0, NULL, 0, NULL, 1,
      &desktopImageBarrier);

  this->desktopImageLayout = desktopImageBarrier.newLayout;
}

static void vulkan_framebufferBarrier(struct Inst * this, uint32_t imageIndex)
{
  // Make framebuffer writes visible to subsequent draw calls
  struct VkImageMemoryBarrier imageBarrier =
  {
    .sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,
    .srcAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT,
    .dstAccessMask = VK_ACCESS_INPUT_ATTACHMENT_READ_BIT,
    .oldLayout = VK_IMAGE_LAYOUT_GENERAL,
    .newLayout = VK_IMAGE_LAYOUT_GENERAL,
    .srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
    .dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
    .image = this->swapchainImages[imageIndex],
    .subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT,
    .subresourceRange.levelCount = 1,
    .subresourceRange.layerCount = 1
  };

  vkCmdPipelineBarrier(this->commandBuffer,
      VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,
      VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, VK_DEPENDENCY_BY_REGION_BIT, 0,
      NULL, 0, NULL, 1, &imageBarrier);
}

static bool vulkan_recordCommandBuffer(struct Inst * this, uint32_t imageIndex,
    bool drawImGui, LG_RendererRotate rotate)
{
  struct VkCommandBufferBeginInfo beginInfo =
  {
    .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,
    .flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT
  };

  VkResult result = vkBeginCommandBuffer(this->commandBuffer, &beginInfo);
  if (result != VK_SUCCESS)
  {
    DEBUG_ERROR("Failed to begin command buffer (VkResult: %d)", result);
    return false;
  }

  vulkan_preRenderBarrier(this);

  if (!vulkan_cursorPreRender(this->cursor))
    return false;

  VkRect2D renderArea =
  {
    .extent = this->swapchainExtent
  };

  union VkClearValue clearValues[] =
  {
    // Swapchain image
    { .color = { .float32 = { 0.0f, 0.0f, 0.0f, 0.0f } } },
    // ImGui render target
    { .color = { .float32 = { 0.0f, 0.0f, 0.0f, 0.0f } } }
  };

  struct VkRenderPassBeginInfo renderPassBegin =
  {
    .sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,
    .renderPass = this->renderPass,
    .framebuffer = this->framebuffers[imageIndex],
    .renderArea = renderArea,
    .clearValueCount = ARRAY_LENGTH(clearValues),
    .pClearValues = clearValues
  };

  vkCmdBeginRenderPass(this->commandBuffer, &renderPassBegin,
      VK_SUBPASS_CONTENTS_INLINE);

  // Subpass 0: ImGui
  if (drawImGui)
    vulkan_imGuiRender(this->imGui);

  vkCmdNextSubpass(this->commandBuffer, VK_SUBPASS_CONTENTS_INLINE);

  // Subpass 1: main
  VkViewport viewport =
  {
    .width = (float) this->swapchainExtent.width,
    .height = (float) this->swapchainExtent.height,
    .minDepth = 0.0f,
    .maxDepth = 1.0f
  };

  vkCmdSetViewport(this->commandBuffer, 0, 1, &viewport);

  vkCmdSetScissor(this->commandBuffer, 0, 1, &renderArea);

  vkCmdBindPipeline(this->commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS,
      this->pipeline);

  vkCmdBindDescriptorSets(this->commandBuffer,
      VK_PIPELINE_BIND_POINT_GRAPHICS, this->pipelineLayout, 0, 1,
      &this->descriptorSets[0], 0, NULL);

  if (this->desktopImage)
  {
    vkCmdBindDescriptorSets(this->commandBuffer,
        VK_PIPELINE_BIND_POINT_GRAPHICS, this->pipelineLayout, 1, 1,
        &this->descriptorSets[1], 0, NULL);

    vkCmdDraw(this->commandBuffer, 3, 1, 0, 0);
  }

  vulkan_framebufferBarrier(this, imageIndex);

  bool renderedCursor = vulkan_cursorRender(this->cursor,
      (this->format.rotate + rotate) % LG_ROTATE_MAX, this->width,
      this->height);

  if (drawImGui)
  {
    if (renderedCursor)
      vulkan_framebufferBarrier(this, imageIndex);

    vkCmdSetScissor(this->commandBuffer, 0, 1, &renderArea);

    vulkan_imGuiBlend(this->imGui);
  }

  vkCmdEndRenderPass(this->commandBuffer);

  result = vkEndCommandBuffer(this->commandBuffer);
  if (result != VK_SUCCESS)
  {
    DEBUG_ERROR("Failed to end command buffer (VkResult: %d)", result);
    return false;
  }

  return true;
}

static bool vulkan_render(LG_Renderer * renderer, LG_RendererRotate rotate,
    const bool newFrame, const bool invalidateWindow,
    void (*preSwap)(void * udata), void * udata)
{
  struct Inst * this = UPCAST(struct Inst, renderer);

  struct Rect damage[KVMFR_MAX_DAMAGE_RECTS + MAX_OVERLAY_RECTS + 2];
  int damageIdx = app_renderOverlay(damage, MAX_OVERLAY_RECTS);
  bool drawImGui = damageIdx != 0;

  vulkan_updateUniformBuffer(this->desktopUniformBufferMap, this->translateX,
      this->translateY, this->scaleX, this->scaleY, rotate);

  uint32_t imageIndex = vulkan_acquireSwapchainImage(this);
  if (imageIndex == UINT32_MAX)
    goto err;

  vulkan_updateDescriptorSet0(this->device, this->descriptorSets[0],
      this->swapchainImageViews[imageIndex], this->imGuiImageView);

  if (!vulkan_recordCommandBuffer(this, imageIndex, drawImGui, rotate))
    goto err;

  VkPipelineStageFlags waitDstStageMask =
      VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;

  struct VkSubmitInfo submitInfo =
  {
    .sType = VK_STRUCTURE_TYPE_SUBMIT_INFO,
    .waitSemaphoreCount = 1,
    .pWaitSemaphores = &this->swapchainAcquireSemaphore,
    .pWaitDstStageMask = &waitDstStageMask,
    .commandBufferCount = 1,
    .pCommandBuffers = &this->commandBuffer,
    .signalSemaphoreCount = 1,
    .pSignalSemaphores = &this->swapchainReleaseSemaphore
  };

  VkResult result = vkQueueSubmit(this->queue, 1, &submitInfo, this->fence);
  if (result != VK_SUCCESS)
  {
    DEBUG_ERROR("Failed to submit command buffer (VkResult: %d)", result);
    goto err;
  }

  VkPresentInfoKHR presentInfo =
  {
    .sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR,
    .waitSemaphoreCount = 1,
    .pWaitSemaphores = &this->swapchainReleaseSemaphore,
    .swapchainCount = 1,
    .pSwapchains = &this->swapchain,
    .pImageIndices = &imageIndex
  };

  result = vkQueuePresentKHR(this->queue, &presentInfo);
  if (result != VK_SUCCESS)
  {
    DEBUG_ERROR("Failed to present swapchain image (VkResult: %d)", result);
    goto err_wait;
  }

  if (!vulkan_waitFence(this->device, this->fence))
    goto err_wait;

  return true;

err_wait:
  vkQueueWaitIdle(this->queue);

err:
  return false;
}

static void * vulkan_createTexture(LG_Renderer * renderer,
  int width, int height, uint8_t * data)
{
  struct Inst * this = UPCAST(struct Inst, renderer);

  return vulkan_imGuiCreateTexture(this->imGui, width, height, data);
}

static void vulkan_freeTexture(LG_Renderer * renderer, void * texture)
{
  struct Inst * this = UPCAST(struct Inst, renderer);

  vulkan_imGuiFreeTexture(this->imGui, texture);
}

static void vulkan_spiceConfigure(LG_Renderer * renderer, int width, int height)
{
  DEBUG_FATAL("vulkan_spiceConfigure not implemented");
}

static void vulkan_spiceDrawFill(LG_Renderer * renderer, int x, int y, int width,
    int height, uint32_t color)
{
  DEBUG_FATAL("vulkan_spiceDrawFill not implemented");
}

static void vulkan_spiceDrawBitmap(LG_Renderer * renderer, int x, int y, int width,
    int height, int stride, uint8_t * data, bool topDown)
{
  DEBUG_FATAL("vulkan_spiceDrawBitmap not implemented");
}

static void vulkan_spiceShow(LG_Renderer * renderer, bool show)
{
  DEBUG_FATAL("vulkan_spiceShow not implemented");
}

struct LG_RendererOps LGR_Vulkan =
{
  .getName       = vulkan_getName,
  .setup         = vulkan_setup,
  .create        = vulkan_create,
  .initialize    = vulkan_initialize,
  .deinitialize  = vulkan_deinitialize,
  .supports      = vulkan_supports,
  .onRestart     = vulkan_onRestart,
  .onResize      = vulkan_onResize,
  .onMouseShape  = vulkan_onMouseShape,
  .onMouseEvent  = vulkan_onMouseEvent,
  .onFrameFormat = vulkan_onFrameFormat,
  .onFrame       = vulkan_onFrame,
  .renderStartup = vulkan_renderStartup,
  .render        = vulkan_render,
  .createTexture = vulkan_createTexture,
  .freeTexture   = vulkan_freeTexture,

  .spiceConfigure  = vulkan_spiceConfigure,
  .spiceDrawFill   = vulkan_spiceDrawFill,
  .spiceDrawBitmap = vulkan_spiceDrawBitmap,
  .spiceShow       = vulkan_spiceShow
};
